<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,400italic,700italic,700" rel="stylesheet" type="text/css"> <link rel="stylesheet" type="text/css" href="/style.css"/> <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>
  BenTheElder ~ Blog
  </title>
</head>
<body>
<!DOCTYPE html>
<html lang="en">
<body>
<div class="header">
<a href="/">BenTheElder</a>
</div>
<div class="nav-box card">
<a href="/">Home</a><a href="/projects.html">Projects</a><a href="/resume.html">Resume</a><a href="/blog.html" class="current">Blog</a>
</div>
<div class="card blog-content">
<p class="title">
CreatureBox: An obstacle avoidance evolutionary simulation - Jan. 2, 2016
</p>
<p><a href="github.com/BenTheElder/creaturebox">CreatureBox</a> is a simple evolutionary obstacle avoidance demo I wrote inspired by <a href="http://otoro.net">studio otoro</a>'s awesome <a href="http://blog.otoro.net/2015/05/07/creatures-avoiding-planks/">creatures avoiding planks</a>. I wanted to build something similar for fun and try out golang's <a href="https://github.com/golang/mobile">Go mobile</a> project as well, so over the break between semsters I took a little time to write one.</p>
<h4 id="gomobile">gomobile</h4>
<p>The first thing I did was get gomobile up and running, and create a basic main loop to handle events and draw a quad to the screen during paint events. One interesting effect of using gomobile is that CreatureBox should work on Windows, OS X, Linux, Android, iOS, etc, which is pretty cool. The library and tooling provide a common ground with a portable event model and opengl access provided for you. I have only tested on OS X El Capitan and Android Marshmallow, but it seems to work well, and it's really nice to have the mobile code running on desktop and mobile without an emulator. On the bad side, I couldn't find a good method to attain a vsync like refresh rate, all of the continuously updating pure go demos in the gomobile repository simply create a new paint event at the end of the previous paint event, which causes the app to use excessive processing time on my laptop. My &quot;solution&quot; was to call <code>time.Sleep()</code> on desktop at the end of each paint event in order to throttle the processor time used. The gomobile tooling was definitely very interesting, but pure go apps are definitely still a little rough around the edges. I think it made a pretty resaonable compromise in this case, and it made focusing on the simulation logic very straight-forward.<br />
<br />
</p>
<h4 id="the-simulation">The Simulation</h4>
<p>The next thing I did was layout the project structure, divided into the application layer, the simulation, and the simulation further divided into the simulation logic and the &quot;Brain&quot; logic.</p>
<p>The simulation uses <a href="https://github.com/llgcode">llgcode</a>'s awesome <a href="https://github.com/llgcode/draw2d">draw2d</a> package to draw each frame to a fixed size canvas in order to simplify a number of things. In particular this allowed me to detect collisions and perform raycasts by traversing the canvas's pixels after drawing the background, walls, and obstacles. Any location with a non-background colored pixel is then obviously a wall or an obstacle, and in this case I intended to treat them the same, so this is allowed me to cheaply and easily implement &quot;killing&quot; creatures that touch a wall or a moving obstacle.</p>
<h4 id="brains">&quot;Brains&quot;</h4>
<p>I then implemented the &quot;brains&quot; for the creatures, mimicing the design described in the studio otoro blog post. Each creature has a fully connected two layer (input and output) neural network. Most of the outputs are recurrent like the studio otoro demo. Each creature receives a number of &quot;distance to edge or obstacle&quot; inputs in evenly distributed directions about them as well as the previous output for the recurrent nodes, and produces a turn and move output used for turning left/right and moving forward/backwards every frame. These are then scaled, and applied. You can see which way a creature is facing by the white dot drawn on them towards their current &quot;forward&quot; direction.</p>
<h4 id="evolution">Evolution</h4>
<p>Lastly I implemented the key component (evolution) by adding logic to track the number of frames each creature has been &quot;alive&quot; for, storing the weights of the best creatures. I also performed a finalpass over the logic to optimize things a little bit (mainly minimizing un-neccessary allocations).<br />
<br />
Every n-th frame a number of new creatures are spawned, some of which have brain patterns cloned from the all time best creatures so far, some with a combination of two of the best, and some purely random. Eventually creatures better at staying alive will become more common but there will always be purely random creatures. Creatures do not &quot;breed&quot; or &quot;grow&quot; like the studio otoro demo, but they do have a &quot;frames alive&quot; score used to determine which brain patterns perform best, and the best are spontaneously reproduced each cycle.<br />
<br />
The color of each creature is based on the average of their brain weights divided into 3 chunks for the RGB channels allowing some limited visualization of similarity between creatures (&quot;clones&quot; will be the same color for example).</p>
<h4 id="wrap-up">Wrap-Up:</h4>
All told, this project was pretty fun to work on.<br />
Here's two a gifs of the result running on my laptop (the right gif has more evolved creatures):<br />
<br />

<div style="text-align:center">
<p><img src="/images/creaturebox_demo.gif" width="310" height="518" alt="gif of CreatureBox running on my laptop"></img> <img src="/images/creaturebox_demo_2.gif" width="310" height="518" alt="gif of CreatureBox running on my laptop with more evolved creatures"></img></p>
</div>
<p><br />
<br />
I posted the project to <a href="https://twitter.com/BenTheElder">my twitter</a> before I wrote this writeup and receive and kind reply from <a href="https://twitter.com/hardmaru"><span class="citation">@hardmaru</span></a> of <a href="http://otoro.net">studio otoro</a>:</p>
<blockquote class="twitter-tweet tw-align-center" lang="en">
<p lang="en" dir="ltr">
<a href="https://twitter.com/BenTheElder"><span class="citation">@BenTheElder</span></a> nice implementation of creatures-avoiding-planks in golang. Have you thought abt using q-learning n-nets rather than evolution?
</p>
â€” hardmaru (<span class="citation">@hardmaru</span>) <a href="https://twitter.com/hardmaru/status/683177164447981568">January 2, 2016</a>
</blockquote>
<p>I may just have to explore that for my next project (I <a href="https://twitter.com/BenTheElder/status/683178992606810112">replied back</a>).</p>
<div style="clear: both;">

</div>
</div>
</div>
<div class="card footer">
<p>
This Website is Open-<a href="https://github.com/BenTheElder/site">Source</a>.
</p>
</div>
</body>
</html>
</body>
</html>
